/**
 * Encryption utilities module
 * Provides symmetric encryption and decryption using OpenPGP
 */

import * as openpgp from 'openpgp';

/**
 * Encrypt text symmetrically using a password
 *
 * @param {string} plaintext - Text to encrypt
 * @param {string} password - Password for encryption
 * @returns {Promise<string>} - Encrypted text (ASCII armored format)
 * @throws {Error} - Throws if encryption fails
 */
export async function encryptWithPassword(plaintext, password) {
  try {
    if (!plaintext || typeof plaintext !== 'string') {
      throw new Error('Plaintext must be a non-empty string.');
    }

    if (!password || typeof password !== 'string') {
      throw new Error('Password must be a non-empty string.');
    }

    // Perform symmetric encryption with OpenPGP using GPG-compatible settings
    const message = await openpgp.createMessage({ text: plaintext });
    const encrypted = await openpgp.encrypt({
      message,
      passwords: [password],
      format: 'armored', // Output as ASCII armored format
      config: {
        preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256,
        preferredHashAlgorithm: openpgp.enums.hash.sha256,
        preferredCompressionAlgorithm: openpgp.enums.compression.zip,
        s2kIterationCountByte: 0x90, // High iteration count for stronger key derivation
        aeadProtect: false, // Disable AEAD for better GPG compatibility
      },
    });

    return encrypted;
  } catch (error) {
    throw new Error(`Encryption failed: ${error.message}`);
  }
}

/**
 * Decrypt encrypted content using a password
 *
 * @param {string|ArrayBuffer} encryptedData - Encrypted data (ASCII armored string or binary ArrayBuffer)
 * @param {string} password - Decryption password
 * @returns {Promise<string>} - Decrypted plaintext
 * @throws {Error} - Throws if decryption fails or password is incorrect
 */
export async function decryptWithPassword(encryptedData, password) {
  try {
    if (!encryptedData) {
      throw new Error('Encrypted data cannot be empty.');
    }

    if (!password || typeof password !== 'string') {
      throw new Error('Password must be a non-empty string.');
    }

    let message;
    let decryptedSuccess = false;
    const errors = [];

    // Helper for multiple decryption attempts (for compatibility)
    const tryDecrypt = async (method, data, description) => {
      try {
        if (method === 'armored') {
          message = await openpgp.readMessage({ armoredMessage: data });
        } else if (method === 'binary') {
          message = await openpgp.readMessage({ binaryMessage: data });
        }

        const { data: decrypted } = await openpgp.decrypt({
          message,
          passwords: [password],
        });

        decryptedSuccess = true;
        return decrypted;
      } catch (error) {
        errors.push(`${description}: ${error.message}`);
        return null;
      }
    };

    if (typeof encryptedData === 'string') {
      // Try ASCII armored format
      const result1 = await tryDecrypt('armored', encryptedData, 'string-ASCII armored');
      if (result1) return result1;

      // Try converting string to binary and decrypt
      const encoder = new TextEncoder();
      const binaryData = encoder.encode(encryptedData);
      const result2 = await tryDecrypt('binary', binaryData, 'string-to-binary');
      if (result2) return result2;

    } else if (encryptedData instanceof ArrayBuffer) {
      const uint8Data = new Uint8Array(encryptedData);

      // Try binary decryption
      const result1 = await tryDecrypt('binary', uint8Data, 'ArrayBuffer-binary');
      if (result1) return result1;

      // Try converting binary data to text and treating it as ASCII armored
      try {
        const textDecoder = new TextDecoder('utf-8', { fatal: false });
        const textContent = textDecoder.decode(encryptedData);
        if (textContent.includes('-----BEGIN PGP MESSAGE-----')) {
          const result2 = await tryDecrypt('armored', textContent, 'ArrayBuffer-to-ASCII armored');
          if (result2) return result2;
        }
      } catch {
        // Ignore text decoding errors
      }
    } else {
      throw new Error('Unsupported encrypted data format.');
    }

    // Analyze decryption errors
    if (!decryptedSuccess) {
      const passwordError = errors.some(err =>
        err.includes('Incorrect password') ||
        err.includes('Session key decryption failed') ||
        err.includes('Invalid session key')
      );

      if (passwordError) {
        throw new Error('Invalid password — unable to decrypt.');
      }

      const formatError = errors.some(err =>
        err.includes('not a valid') ||
        err.includes('Invalid') ||
        err.includes('ASCII armor') ||
        err.includes('No data')
      );

      if (formatError) {
        console.warn('Decryption attempt details:', errors);
        throw new Error('Incompatible GPG file format — please ensure the file was generated by a standard GPG tool or this app.');
      }

      throw new Error(`Decryption failed: ${errors[0] || 'Unknown error.'}`);
    }

    throw new Error('Unexpected error during decryption.');
  } catch (error) {
    if (
      error.message.includes('Invalid password') ||
      error.message.includes('format') ||
      error.message.includes('Unsupported encrypted data format')
    ) {
      throw error;
    }

    throw new Error(`Decryption failed: ${error.message}`);
  }
}

/**
 * Validate password strength
 *
 * @param {string} password - Password to validate
 * @returns {Object} - { strength, message }
 */
export function validatePasswordStrength(password) {
  if (!password || typeof password !== 'string') {
    return {
      strength: 'weak',
      message: 'Password cannot be empty.',
    };
  }

  const length = password.length;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecialChar = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);

  let score = 0;
  if (length >= 8) score += 1;
  if (length >= 12) score += 1;
  if (hasUpperCase) score += 1;
  if (hasLowerCase) score += 1;
  if (hasNumbers) score += 1;
  if (hasSpecialChar) score += 1;

  if (score < 3) {
    return {
      strength: 'weak',
      message: 'Weak password: use at least 8 characters, including upper/lowercase, numbers, and special symbols.',
    };
  } else if (score < 5) {
    return {
      strength: 'medium',
      message: 'Medium password: consider increasing length and complexity.',
    };
  } else {
    return {
      strength: 'strong',
      message: 'Strong password: high security.',
    };
  }
}

/**
 * Validate that two passwords match
 *
 * @param {string} password
 * @param {string} confirmPassword
 * @returns {Object} - { isValid, message }
 */
export function validatePasswordMatch(password, confirmPassword) {
  if (!password || typeof password !== 'string') {
    return {
      isValid: false,
      message: 'Password cannot be empty.',
    };
  }

  if (!confirmPassword || typeof confirmPassword !== 'string') {
    return {
      isValid: false,
      message: 'Confirmation password cannot be empty.',
    };
  }

  if (password !== confirmPassword) {
    return {
      isValid: false,
      message: 'Passwords do not match.',
    };
  }

  return {
    isValid: true,
    message: 'Passwords match.',
  };
}

/**
 * Generate a random password
 *
 * @param {number} length - Password length (default: 16)
 * @param {Object} options - Options for character inclusion
 * @param {boolean} options.includeUppercase - Include uppercase letters
 * @param {boolean} options.includeLowercase - Include lowercase letters
 * @param {boolean} options.includeNumbers - Include numbers
 * @param {boolean} options.includeSpecialChars - Include special characters
 * @returns {string} - Generated password
 */
export function generateRandomPassword(length = 16, options = {}) {
  const { includeUppercase = true, includeLowercase = true, includeNumbers = true, includeSpecialChars = true } = options;

  let charset = '';
  if (includeUppercase) charset += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  if (includeLowercase) charset += 'abcdefghijklmnopqrstuvwxyz';
  if (includeNumbers) charset += '0123456789';
  if (includeSpecialChars) charset += '!@#$%^&*()_+-=[]{}|;:,.<>?';

  if (!charset) {
    throw new Error('At least one character type must be selected.');
  }

  let password = '';
  const randomValues = new Uint32Array(length);
  crypto.getRandomValues(randomValues);

  for (let i = 0; i < length; i++) {
    password += charset[randomValues[i] % charset.length];
  }

  return password;
}

/**
 * Detect GPG file format type
 *
 * @param {string|ArrayBuffer|Uint8Array} data - File data
 * @returns {Object} - { type, isBinary }
 */
export function detectGpgFormat(data) {
  try {
    if (!data) {
      return { type: 'unknown', isBinary: false };
    }

    if (typeof data === 'string') {
      const trimmed = data.trim();
      if (trimmed.startsWith('-----BEGIN PGP MESSAGE-----')) {
        return { type: 'ascii-armor', isBinary: false };
      }
      return { type: 'unknown-text', isBinary: false };
    }

    let uint8Data;
    if (data instanceof ArrayBuffer) {
      uint8Data = new Uint8Array(data);
    } else if (data instanceof Uint8Array) {
      uint8Data = data;
    } else {
      return { type: 'unknown', isBinary: false };
    }

    const header = '-----BEGIN PGP MESSAGE-----';
    const headerBytes = new TextEncoder().encode(header);

    if (uint8Data.length >= headerBytes.length) {
      let isArmor = true;
      for (let i = 0; i < headerBytes.length; i++) {
        if (uint8Data[i] !== headerBytes[i]) {
          isArmor = false;
          break;
        }
      }
      if (isArmor) {
        return { type: 'ascii-armor', isBinary: false };
      }
    }

    if (uint8Data.length >= 2) {
      const packetTag = uint8Data[0];
      if ((packetTag & 0x80) === 0x80) {
        return { type: 'binary-packet', isBinary: true };
      }
    }

    return { type: 'binary', isBinary: true };
  } catch {
    return { type: 'unknown', isBinary: false };
  }
}

/**
 * Secure string comparison to prevent timing attacks
 *
 * @param {string} a - First string
 * @param {string} b - Second string
 * @returns {boolean} - True if equal, otherwise false
 */
export function secureCompare(a, b) {
  if (typeof a !== 'string' || typeof b !== 'string') {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  }

  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }

  return result === 0;
}
